diff --git a/gripx_control/launch/gripx_control2.launch b/gripx_control/launch/gripx_control2.launch
index 8294f63..6fd9980 100644
--- a/gripx_control/launch/gripx_control2.launch
+++ b/gripx_control/launch/gripx_control2.launch
@@ -13,8 +13,17 @@
       file="$(find gripx_control)/config/gripx_control.yaml"/>
 
       <!-- Load the controllers from ros -->
-  <node name="gripx_controller_spawner" pkg="controller_manager" type="spawner" 
+  <node name="controller_spawner" pkg="controller_manager" type="spawner" ns="/"
         args="arm_position_controller"/>
+
+  <!-- convert joint states to TF transforms for rviz, etc -->
+  <!-- <node name="robot_state_publisher" pkg="robot_state_publisher" type="robot_state_publisher"
+    respawn="false" output="screen">
+    <remap from="/joint_states" to="/joint_states" />
+  </node> -->
+
+
+
     <!-- Lad Rviz Config -->
     <arg name="gui" default="true" />
     <arg name="rvizconfig" default="$(find gripx_description)/rviz/urdf.rviz" />
diff --git a/gripx_description/urdf/gripx_gazebo.urdf b/gripx_description/urdf/gripx_gazebo.urdf
index 94ce9d8..37c35a9 100644
--- a/gripx_description/urdf/gripx_gazebo.urdf
+++ b/gripx_description/urdf/gripx_gazebo.urdf
@@ -349,5 +349,20 @@
   <plugin name="gazebo_ros_control" filename="libgazebo_ros_control.so">
     <robotNamespace>/</robotNamespace>
   </plugin>
+
+
+
+<!--   <plugin name="joint_state_publisher" filename="libgazebo_ros_joint_state_publisher.so">
+    <robotNamespace>/</robotNamespace>
+    <jointName>joint1, 
+                joint_2, 
+                   joint_3, 
+                   joint_4, 
+                   joint_5,
+                   joint_6
+        </jointName>
+  </plugin> -->
+
+
 </gazebo>
 </robot>
diff --git a/gripx_gazebo/launch/gazebo.launch b/gripx_gazebo/launch/gazebo.launch
index 778962d..6491c72 100644
--- a/gripx_gazebo/launch/gazebo.launch
+++ b/gripx_gazebo/launch/gazebo.launch
@@ -26,6 +26,7 @@
 
   <node pkg="robot_state_publisher" type="robot_state_publisher"  name="robot_state_publisher">
     <param name="publish_frequency" type="double" value="30.0" />
+    <remap from="/joint_states" to="/gripx/joint_states" />
   </node>
 
 </launch>
diff --git a/gripx_moveit_config/launch/moveit_planning_execution.launch b/gripx_moveit_config/launch/moveit_planning_execution.launch
index a97601c..5d4b778 100644
--- a/gripx_moveit_config/launch/moveit_planning_execution.launch
+++ b/gripx_moveit_config/launch/moveit_planning_execution.launch
@@ -4,10 +4,18 @@
 
 	<!-- does not make MoveIt/Gazebo use the fake controllers, it only makes sure that joint_state_publisher gathers the JointStates published on /move_group/fake_controller_joint_states and republishes them on /joint_states. -->
 	<!-- https://answers.ros.org/question/252114/failed-to-validate-trajectory-couldnt-receive-full-current-joint-state-within-1s-error/ -->
-	<node name="joint_state_publisher" pkg="joint_state_publisher" type="joint_state_publisher">
+<!-- 	<node name="joint_state_publisher" pkg="joint_state_publisher" type="joint_state_publisher">
     <param name="/use_gui" value="false"/>
     <rosparam param="/source_list">[/move_group/fake_controller_joint_states]</rosparam>
+  </node> -->
+
+
+  <node name="joint_state_publisher" pkg="joint_state_publisher" type="joint_state_publisher">
+    <param name="/use_gui" value="false"/>
+    <rosparam param="/source_list">[/joint_states]</rosparam>
   </node>
+
+
 	<!-- Load the SRDF and other configuration files -->
   <include file="$(find gripx_moveit_config)/launch/planning_context.launch"/>
 
@@ -22,6 +30,6 @@
   <include file="$(find gripx_control)/launch/gripx_control2.launch"/>
 
 <!--    The visualization component of MoveIt!-->  
-<include file="$(find gripx_moveit_config)/launch/moveit_rviz.launch"/>
+<!-- <include file="$(find gripx_moveit_config)/launch/moveit_rviz.launch"/> -->
 
 </launch>
\ No newline at end of file
diff --git a/gripx_moveit_config/launch/moveit_pllanning_execution.launch b/gripx_moveit_config/launch/moveit_pllanning_execution.launch
deleted file mode 100644
index ef6bd85..0000000
--- a/gripx_moveit_config/launch/moveit_pllanning_execution.launch
+++ /dev/null
@@ -1,14 +0,0 @@
-<?xml version="1.0"?>
-<launch>
-
-  <!--  The planning and execution components of MoveIt! configured to 
-   publish the current configuration of the robot (simulated or real) 
-   and the current state of the world as seen by the planner -->
-  <include file="$(find gripx_moveit_config)/launch/move_group.launch">
-    <arg name="publish_monitored_planning_scene" value="true" />
-  </include>
-
-<!--    The visualization component of MoveIt!-->  
-<include file="$(find gripx_moveit_config)/launch/moveit_rviz.launch"/>
-
-</launch>
\ No newline at end of file
diff --git a/gripx_moveit_config/launch/moveit_rviz.launch b/gripx_moveit_config/launch/moveit_rviz.launch
index a4605c0..5fbdfcf 100644
--- a/gripx_moveit_config/launch/moveit_rviz.launch
+++ b/gripx_moveit_config/launch/moveit_rviz.launch
@@ -8,8 +8,8 @@
   <arg     if="$(eval rviz_config=='')" name="command_args" value="" />
   <arg unless="$(eval rviz_config=='')" name="command_args" value="-d $(arg rviz_config)" />
 
-  <node name="$(anon rviz)" launch-prefix="$(arg launch_prefix)" pkg="rviz" type="rviz" respawn="false"
+  <!-- <node name="$(anon rviz)" launch-prefix="$(arg launch_prefix)" pkg="rviz" type="rviz" respawn="false"
         args="$(arg command_args)" output="screen">
-  </node>
+  </node> -->
 
 </launch>
diff --git a/moveit_packages/controllers/src/pose_control.cpp b/moveit_packages/controllers/src/pose_control.cpp
index b220d83..a3f1de3 100644
--- a/moveit_packages/controllers/src/pose_control.cpp
+++ b/moveit_packages/controllers/src/pose_control.cpp
@@ -13,6 +13,11 @@
 // Used to  transform between tf2_quaternion and geometry_msgs quaternion
 #include <tf2_geometry_msgs/tf2_geometry_msgs.h>
 
+#include <sstream>
+#include <iostream>
+using namespace std;
+
+
 int main(int argc, char** argv)
 {
   ros::init(argc, argv, "pose_controller");
@@ -45,12 +50,19 @@ int main(int argc, char** argv)
   std::copy(move_group.getJointModelGroupNames().begin(), move_group.getJointModelGroupNames().end(),
             std::ostream_iterator<std::string>(std::cout, ", "));
 
+  //To set a new start state
+  moveit::core::RobotState start_state(*move_group.getCurrentState());
+
+  
+  //Set a different planner id:
+  // move_group.setPlannerId("RRTConnectkConfigDefault");
+
   // Planning to a Pose goal and executing
 
 
   // Quaternion transformation
   tf2::Quaternion myQuaternion;
-  myQuaternion.setRPY( -1.5707, 0, 1.5707 );  // Create this quaternion from roll/pitch/yaw (in radians)
+  myQuaternion.setRPY( -1.57, 0, 0 );  // Create this quaternion from roll/pitch/yaw (in radians)
   // Normalize to 1
   myQuaternion.normalize();
 
@@ -61,14 +73,77 @@ int main(int argc, char** argv)
   target_pose1.orientation.x = myQuaternion[0];
   target_pose1.orientation.y = myQuaternion[1];
   target_pose1.orientation.z = myQuaternion[2];
-  target_pose1.orientation.w = myQuaternion[3]; // move_group.setPlanningTime(10.0);
-  target_pose1.position.x = 0.4;
-  target_pose1.position.y = 0.1;
-  target_pose1.position.z = 0.4;
-  move_group.setGoalOrientationTolerance(0.5);
-  move_group.setPoseTarget(target_pose1);
-  move_group.move();
-  
+  target_pose1.orientation.w = myQuaternion[3]; 
+
+
+   int count = 0;
+
+  while (ros::ok())
+  {
+    cout << "Enter: X: Y: Z:" <<endl;
+    cin >> target_pose1.position.x >>target_pose1.position.y >> target_pose1.position.z;
+
+    // target_pose1.orientation.w = 1;
+    // move_group.setPlanningTime(10.0);
+    // target_pose1.position.x = 0.4;
+    // target_pose1.position.y = 0.3;
+    // target_pose1.position.z = 0.5;
+
+    // move_group.setOrientationTarget( myQuaternion[0], myQuaternion[1], myQuaternion[2], myQuaternion[3],
+    //   move_group.getEndEffectorLink());
+    // move_group.setGoalOrientationTolerance(1);
+    move_group.setPoseTarget(target_pose1, move_group.getEndEffectorLink());
+    // move_group.setApproximateJointValueTarget(target_pose1, move_group.getEndEffectorLink());
+    cout << count;
+    move_group.move();
+    ++count;
+    start_state.setFromIK(joint_model_group, target_pose1);
+    move_group.setStartState(start_state);
+
+     // Planning a Cartesian Path by interpolating through waypoints
+
+    //Create a vector of poses
+    std::vector<geometry_msgs::Pose> waypoints;
+
+       //Push the current endeffector pose inte the vector
+    waypoints.push_back(target_pose1);
+
+    geometry_msgs::Pose target_pose = target_pose1;
+
+    target_pose.position.z += 0.1;
+    waypoints.push_back(target_pose);  // down
+
+    target_pose.position.z -= 0.1;
+    waypoints.push_back(target_pose);  // down
+
+    target_pose.position.z -= 0.1;
+    waypoints.push_back(target_pose);  // up and left
+
+    // Set a slower execution speed
+    move_group.setMaxVelocityScalingFactor(0.1);
+
+    //Give the planner more time
+    move_group.setPlanningTime(15.0);
+
+    //allow several planning attemps
+    move_group.setNumPlanningAttempts(3);
+
+    // // We want the Cartesian path to be interpolated at a resolution of 1 cm
+    // // which is why we will specify 0.01 as the max step in Cartesian
+    // // translation.  We will specify the jump threshold as 0.0, effectively disabling it.
+    // // Warning - disabling the jump threshold while operating real hardware can cause
+    // // large unpredictable motions of redundant joints and could be a safety issue
+    moveit_msgs::RobotTrajectory trajectory;
+    const double jump_threshold = 0.0;
+    const double eef_step = 0.01;
+    double fraction = move_group.computeCartesianPath(waypoints, eef_step, jump_threshold, trajectory);
+    ROS_INFO_NAMED("tutorial", "Visualizing plan 4 (Cartesian path) (%.2f%% acheived)", fraction * 100.0);
+
+    //Execute the trajectory
+    move_group.execute(trajectory);
+
+  }
+    
   ros::shutdown();
   return 0;
 }
